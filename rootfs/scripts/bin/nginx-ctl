#!/bin/sh

# Define the lock file
LOCKFILE="/tmp/$(basename $0).lock"
CONFIG_FILE="config.json"
# Ensure only one instance of the script runs at a time
if [ -e "${LOCKFILE}" ] && kill -0 `cat "${LOCKFILE}"`; then
  echo "An instance of this script is already running."
  exit 1
fi

# Create lock file
trap "rm -f ${LOCKFILE}; exit" INT TERM EXIT
echo $$ > "${LOCKFILE}"

# Global variables
DEFAULT_CONFIGS_PATH="/configs/defaults"
DEBUG=0

# Message handling
LOG() {
  local level="$1"
  shift
  case "$level" in
    DEBUG) [ "$DEBUG" -eq 1 ] && echo "[DEBUG] $*";;
    INFO) echo "[INFO] $*";;
    WARN) echo "[WARN] $*" 1>&2;;
    ERROR) echo "[ERROR] $*" 1>&2;;
    *) echo "$*";;
  esac
}

# Load configuration
load_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "Configuration file $CONFIG_FILE does not exist!"
    exit 1
  fi
  DEBUG=$(jq -r '.debug' "$CONFIG_FILE")
  VERBOSE=$(jq -r '.verbose' "$CONFIG_FILE")
  PATH_TO_SOMETHING=$(jq -r '.path' "$CONFIG_FILE")
  MAX_AGE=$(jq -r '.max_age' "$CONFIG_FILE")
}

# Save configuration
save_config() {
  jq ".debug = $DEBUG | .verbose = $VERBOSE | .path = \"$PATH_TO_SOMETHING\" | .max_age = $MAX_AGE" "$CONFIG_FILE" > "${CONFIG_FILE}.tmp" && mv "${CONFIG_FILE}.tmp" "$CONFIG_FILE"
}

# Config Variables
NGINX_CONF_PATH=/etc/nginx
NGINX_SITE_PATH=/etc/nginx/sites.d
NGINX_MODULES_PATH=/usr/local/nginx/modules
NGINX_CERT_PATH=${NGINX_CONF_PATH}/certs
NGINX_WEBROOT_PATH=/webroot
NGINX_CACHE_PATH=/var/cache/nginx
NGINX_LOG_PATH=/var/log/nginx
MAXMIND_PATH=${NGINX_CONF_PATH}/maxmind
MODSEC_AUDIT_STORAGE=/tmp/modsecurity
MODSEC_DATA_DIR=${MODSEC_AUDIT_STORAGE}/data
MODSEC_TMP_DIR=${MODSEC_AUDIT_STORAGE}/tmp
MODSEC_UPLOAD_DIR=${MODSEC_AUDIT_STORAGE}/upload
SSL_KEY_LENGTH=${SSL_KEY_LENGTH:-4096}
NGINX_WHITELIST_IPS=${NGINX_WHITELIST_IP:-}
if [[ "${NGINX_WHITELIST_IP}" = "/run/secrets/*" ]] && [ -f "${NGINX_WHITELIST_IP}" ]; then
  NGINX_WHITELIST_IPS=$(cat ${NGINX_WHITELIST_IP})
fi

# Begin Maxmind config
MAXMIND_DATABASE=${MAXMIND_DATABASE:-'city'}
MAXMIND_EDITION=${MAXMIND_EDITION:-'geolite2'}
MAXMIND_LICENSE_KEY=${MAXMIND_LICENSE_KEY:-}
if [[ "${MAXMIND_LICENSE_KEY}" = "/run/secrets/*" ]] && [ -f "${MAXMIND_LICENSE_KEY}" ]; then
  MAXMIND_LICENSE_KEY=$(cat ${MAXMIND_LICENSE_KEY})
fi

# End Maxmind Config

# Begin Modsecurity Variables
OPT_MODSEC_CRS_PARANOIA=${CRS_PARANOIA:-1}
OPT_MODSEC_CRS_BLOCKING_PARANOIA=${CRS_BLOCKING_PARANOIA:-1}
OPT_MODSEC_CRS_EXECUTING_PARANOIA=${OPT_MODSEC_CRS_PARANOIA}
OPT_MODSEC_CRS_DETECTION_PARANOIA=${OPT_MODSEC_CRS_BLOCKING_PARANOIA}
OPT_MODSEC_CRS_ENFORCE_BODYPROC_URLENCODED=${CRS_ENFORCE_BODYPROC_URLENCODED:-1}
OPT_MODSEC_CRS_VALIDATE_UTF8_ENCODING=${CRS_VALIDATE_UTF8_ENCODING:-0}
OPT_MODSEC_CRS_ANOMALY_INBOUND=${CRS_ANOMALY_INBOUND:-5}
OPT_MODSEC_CRS_ANOMALY_OUTBOUND=${CRS_ANOMALY_OUTBOUND:-4}
OPT_MODSEC_CRS_ALLOWED_METHODS=${CRS_ALLOWED_METHODS:-'GET POST PUT PATCH HEAD OPTIONS DELETE'}
OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE=${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE:-'|application/x-www-form-urlencoded| |multipart/form-data| |multipart/related| |text/xml| |application/xml| |application/soap+xml| |application/json| |application/cloudevents+json| |application/cloudevents-batch+json|'}
OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE_CHARSET=${CRS_ALLOWED_REQUEST_CONTENT_TYPE_CHARSET:-'utf-8|iso-8859-1|iso-8859-15|windows-1252'}
OPT_MODSEC_CRS_ALLOWED_HTTP_VERSIONS=${CRS_ALLOWED_HTTP_VERSIONS:-'HTTP/1.0 HTTP/1.1 HTTP/2 HTTP/2.0'}
OPT_MODSEC_CRS_RESTRICTED_EXTENSIONS=${CRS_RESTRICTED_EXTENSIONS:-'.asa/ .asax/ .ascx/ .axd/ .backup/ .bak/ .bat/ .cdx/ .cer/ .cfg/ .cmd/ .com/ .config/ .conf/ .cs/ .csproj/ .csr/ .dat/ .db/ .dbf/ .dll/ .dos/ .htr/ .htw/ .ida/ .idc/ .idq/ .inc/ .ini/ .key/ .licx/ .lnk/ .log/ .mdb/ .old/ .pass/ .pdb/ .pol/ .printer/ .pwd/ .rdb/ .resources/ .resx/ .sql/ .swp/ .sys/ .vb/ .vbs/ .vbproj/ .vsdisco/ .webinfo/ .xsd/ .xsx/'}
OPT_MODSEC_CRS_RESTRICTED_HEADERS=${CRS_RESTRICTED_HEADERS:-'/content-encoding/ /proxy/ /lock-token/ /content-range/ /if/ /x-http-method-override/ /x-http-method/ /x-method-override/'}
OPT_MODSEC_CRS_STATIC_EXTENSIONS=${CRS_STATIC_EXTENSIONS:-'/.jpg/ /.jpeg/ /.png/ /.gif/ /.js/ /.css/ /.ico/ /.svg/ /.webp/'}
OPT_MODSEC_CRS_MAX_NUM_ARGS=${CRS_MAX_NUM_ARGS:-'unlimited'}
OPT_MODSEC_CRS_ARG_NAME_LENGTH=${CRS_ARG_NAME_LENGTH:-'unlimited'}
OPT_MODSEC_CRS_ARG_LENGTH=${CRS_ARG_LENGTH:-'unlimited'}
OPT_MODSEC_CRS_TOTAL_ARG_LENGTH=${CRS_TOTAL_ARG_LENGTH:-'unlimited'}
OPT_MODSEC_CRS_MAX_FILE_SIZE=${CRS_MAX_FILE_SIZE:-'unlimited'}
OPT_MODSEC_CRS_COMBINED_FILE_SIZES=${CRS_COMBINED_FILE_SIZES:-'unlimited'}
OPT_MODSEC_CRS_ENABLE_TEST_MARKER=${CRS_ENABLE_TEST_MARKER:-0}
OPT_MODSEC_CRS_REPORTING_LEVEL=${CRS_REPORTING_LEVEL:-2}
OPT_MODSEC_AUDIT_ENGINE=${MODSEC_AUDIT_ENGINE:-"RelevantOnly"}
OPT_MODSEC_AUDIT_LOG_FORMAT=${MODSEC_AUDIT_LOG_FORMAT:-JSON}
OPT_MODSEC_AUDIT_LOG_TYPE=${MODSEC_AUDIT_LOG_TYPE:-Serial}
OPT_MODSEC_AUDIT_LOG=${NGINX_LOG_PATH}/$server_name/modsec_audit.log
OPT_MODSEC_AUDIT_LOG_PARTS=${MODSEC_AUDIT_LOG_PARTS:-'ABIJDEFHZ'}
OPT_MODSEC_AUDIT_STORAGE=${MODSEC_AUDIT_STORAGE}
OPT_MODSEC_DATA_DIR=${MODSEC_DATA_DIR}
OPT_MODSEC_DEBUG_LOG=${MODSEC_DEBUG_LOG:-/dev/null}
OPT_MODSEC_DEBUG_LOGLEVEL=${MODSEC_DEBUG_LOGLEVEL:-0}
OPT_MODSEC_DEFAULT_PHASE1_ACTION=${MODSEC_DEFAULT_PHASE1_ACTION:-"phase:1,pass,log,tag:'\${MODSEC_TAG}'"}
OPT_MODSEC_DEFAULT_PHASE2_ACTION=${MODSEC_DEFAULT_PHASE2_ACTION:-"phase:2,pass,log,tag:'\${MODSEC_TAG}'"}
OPT_MODSEC_PCRE_MATCH_LIMIT_RECURSION=${MODSEC_PCRE_MATCH_LIMIT_RECURSION:-100000}
OPT_MODSEC_PCRE_MATCH_LIMIT=${MODSEC_PCRE_MATCH_LIMIT:-100000}
OPT_MODSEC_REQ_BODY_ACCESS=${MODSEC_REQ_BODY_ACCESS:-on}
OPT_MODSEC_REQ_BODY_LIMIT=${MODSEC_REQ_BODY_LIMIT:-13107200}
OPT_MODSEC_REQ_BODY_LIMIT_ACTION=${MODSEC_REQ_BODY_LIMIT_ACTION:-"Reject"}
OPT_MODSEC_REQ_BODY_JSON_DEPTH_LIMIT=${MODSEC_REQ_BODY_JSON_DEPTH_LIMIT:-512}
OPT_MODSEC_REQ_BODY_NOFILES_LIMIT=${MODSEC_REQ_BODY_NOFILES_LIMIT:-131072}
OPT_MODSEC_RESP_BODY_ACCESS=${MODSEC_RESP_BODY_ACCESS:-on}
OPT_MODSEC_RESP_BODY_LIMIT=${MODSEC_RESP_BODY_LIMIT:-524288}
OPT_MODSEC_RESP_BODY_LIMIT_ACTION=${MODSEC_RESP_BODY_LIMIT_ACTION:-"ProcessPartial"}
OPT_MODSEC_RESP_BODY_MIMETYPE=${MODSEC_RESP_BODY_MIMETYPE:-"text/plain text/html text/xml"}
OPT_MODSEC_RULE_ENGINE=${MODSEC_RULE_ENGINE:-on}
OPT_MODSEC_STATUS_ENGINE=${MODSEC_STATUS_ENGINE:-on}
OPT_MODSEC_TAG=${MODSEC_TAG:-'modsecurity'}
OPT_MODSEC_TMP_DIR=${MODSEC_TMP_DIR}
OPT_MODSEC_TMP_SAVE_UPLOADED_FILES=${MODSEC_TMP_SAVE_UPLOADED_FILES:-on}
OPT_MODSEC_UPLOAD_DIR=${MODSEC_UPLOAD_DIR}
# End modsecurity Variables


# Usage function
usage() {
  echo "Usage: $0 <command> [options]"
  echo ""
  echo "Commands:"
  echo "  sample         Run the sample command."
  echo ""
  echo "Options:"
  echo "  -d             Turn on debug mode."
  echo "  -v             Turn on verbose mode (info level logging)."
  echo "  -h             Display this help message."
}

generate_modules() {
  local MODULE_PATH={$1:-${NGINX_MODULES_PATH}}
  local OUT_PATH="${DEFAULT_CONFIGS_PATH}/modules.conf"
  if [ -f ${MODULE_PATH}/ngx_stream_module.so ]; then
    LOG DEBUG "Adding Stream modules first as there could be dependencies"
    LOG INFO "Adding module       : ngx_stream_module"
    echo "load_module ${MODULE_PATH}/ngx_stream_module.so;" >> "${OUT_PATH}"
  fi
  for file in ${MODULE_PATH}/*.so; do
    if [ "$file" != "${MODULE_PATH}/ngx_stream_module.so" ]; then
      filename=$(basename -s .so $file)
      LOG INFO "Adding module       : ${filename}"
      echo "load_module ${file};" >> "${OUT_PATH}"
    fi
  done
}

generate_dhparams() {
  local OUT_PATH=${1:-${NGINX_CONF_PATH}}
  if [ ! -f ${OUT_PATH}/dhparam.pem ]; then
    LOG DEBUG "Generating dhparam.pem with key length: ${SSL_KEY_LENGTH}"
    openssl dhparam -dsaparam -out ${OUT_PATH}/dhparam.pem ${SSL_KEY_LENGTH};
    # Set permission
    setgroup ${OUT_PATH}/dhparam.pem
  fi
}

generate_whitelist() {
  local WHITELIST_FILE="${DEFAULT_CONFIGS_PATH}/whitelist.conf"
  if [ ! -z "${NGINX_WHITELIST_IPS}" ]; then
    LOG DEBUG "Adding whitelist IP address"
    # NGINX_WHITELIST_IPS is a comma seperated list of IP addresses, loop and add
    for ip in $(echo ${NGINX_WHITELIST_IPS} | sed "s/,/ /g"); do
      LOG DEBUG "Whitelisting IP/IP Range      : ${ip}"
      echo "allow ${ip};" >> "${WHITELIST_FILE}"
    done
  fi
}

generate_modsecurity() {
  local setup_conf_path="${DEFAULT_CONFIGS_PATH}/modsecurity/owasp/crs-setup.conf"
  export OPT_MODSEC_AUDIT_ENGINE=$OPT_MODSEC_AUDIT_ENGINE OPT_MODSEC_AUDIT_LOG=$OPT_MODSEC_AUDIT_LOG OPT_MODSEC_AUDIT_LOG_FORMAT=$OPT_MODSEC_AUDIT_LOG_FORMAT OPT_MODSEC_AUDIT_LOG_PARTS=$OPT_MODSEC_AUDIT_LOG_PARTS OPT_MODSEC_AUDIT_STORAGE=$OPT_MODSEC_AUDIT_STORAGE OPT_MODSEC_AUDIT_LOG_TYPE=$OPT_MODSEC_AUDIT_LOG_TYPE OPT_MODSEC_DATA_DIR=$OPT_MODSEC_DATA_DIR OPT_MODSEC_DEBUG_LOG=$OPT_MODSEC_DEBUG_LOG OPT_MODSEC_DEBUG_LOGLEVEL=$OPT_MODSEC_DEBUG_LOGLEVEL OPT_MODSEC_PCRE_MATCH_LIMIT=$OPT_MODSEC_PCRE_MATCH_LIMIT OPT_MODSEC_PCRE_MATCH_LIMIT_RECURSION=$OPT_MODSEC_PCRE_MATCH_LIMIT_RECURSION OPT_MODSEC_REQ_BODY_ACCESS=$OPT_MODSEC_REQ_BODY_ACCESS OPT_MODSEC_REQ_BODY_LIMIT=$OPT_MODSEC_REQ_BODY_LIMIT OPT_MODSEC_REQ_BODY_JSON_DEPTH_LIMIT=$OPT_MODSEC_REQ_BODY_JSON_DEPTH_LIMIT OPT_MODSEC_REQ_BODY_LIMIT_ACTION=$OPT_MODSEC_REQ_BODY_LIMIT_ACTION OPT_MODSEC_REQ_BODY_NOFILES_LIMIT=$OPT_MODSEC_REQ_BODY_NOFILES_LIMIT OPT_MODSEC_RESP_BODY_ACCESS=$OPT_MODSEC_RESP_BODY_ACCESS OPT_MODSEC_RESP_BODY_LIMIT=$OPT_MODSEC_RESP_BODY_LIMIT OPT_MODSEC_RESP_BODY_LIMIT_ACTION=$OPT_MODSEC_RESP_BODY_LIMIT_ACTION OPT_MODSEC_RESP_BODY_MIMETYPE=$OPT_MODSEC_RESP_BODY_MIMETYPE OPT_MODSEC_RULE_ENGINE=$OPT_MODSEC_RULE_ENGINE OPT_MODSEC_STATUS_ENGINE=$OPT_MODSEC_STATUS_ENGINE OPT_MODSEC_TMP_DIR=$OPT_MODSEC_TMP_DIR OPT_MODSEC_TMP_SAVE_UPLOADED_FILES=$OPT_MODSEC_TMP_SAVE_UPLOADED_FILES OPT_MODSEC_UPLOAD_DIR=$OPT_MODSEC_UPLOAD_DIR
  envsubst '$OPT_MODSEC_AUDIT_ENGINE, $OPT_MODSEC_AUDIT_LOG, $OPT_MODSEC_AUDIT_LOG_FORMAT, $OPT_MODSEC_AUDIT_LOG_PARTS, $OPT_MODSEC_AUDIT_STORAGE, $OPT_MODSEC_AUDIT_LOG_TYPE, $OPT_MODSEC_DATA_DIR, $OPT_MODSEC_DEBUG_LOG,$OPT_MODSEC_DEBUG_LOGLEVEL,$OPT_MODSEC_PCRE_MATCH_LIMIT, $OPT_MODSEC_PCRE_MATCH_LIMIT_RECURSION, $OPT_MODSEC_REQ_BODY_ACCESS, $OPT_MODSEC_REQ_BODY_LIMIT, $OPT_MODSEC_REQ_BODY_JSON_DEPTH_LIMIT, $OPT_MODSEC_REQ_BODY_LIMIT_ACTION, $OPT_MODSEC_REQ_BODY_NOFILES_LIMIT, $OPT_MODSEC_RESP_BODY_ACCESS, $OPT_MODSEC_RESP_BODY_LIMIT, $OPT_MODSEC_RESP_BODY_LIMIT_ACTION, $OPT_MODSEC_RESP_BODY_MIMETYPE, $OPT_MODSEC_RULE_ENGINE, $OPT_MODSEC_STATUS_ENGINE, $OPT_MODSEC_TMP_DIR, $OPT_MODSEC_TMP_SAVE_UPLOADED_FILES, $OPT_MODSEC_UPLOAD_DIR' < /templates/modsecurity-override.conf.template > "${DEFAULT_CONFIGS_PATH}/modsecurity/modsecurity-override.conf"
  DEBUG "Modsecurity OWASP Configuration"

  # Plugins can be disabled entirely by setting CRS_DISABLE_PLUGINS.
  if [ -n "${OPT_MODSEC_CRS_DISABLE_PLUGINS}" ]; then
    echo "Plugins will be disabled"
    return; # Don't use exit on a sourced script
  fi

  # Handle plugins if we have the files.
  # Note: we are careful here to not assume the existance of the "plugins"
  # directory. It is being introduced with version 4 of CRS.
  DEBUG "Modsecurity OWASP Enable plugin"
  # @TODO: Fix this
  #for suffix in "config" "before" "after"; do
  #  if [ -n "$(find /etc/nginx/conf.d/modsecurity/owasp -path "/etc/nginx/conf.d/modsecurity/owasp/plugins/*-${suffix}.conf")" ]; then
  #    # enable if there are config files
  #    sed -i -E "s/^#\s*(.+-${suffix}\.conf)/\1/" /etc/nginx/conf.d/modsecurity/modsecurity.conf
  #  else
  #    # disable if there are no config files
  #    sed -i -E "s/^([^#]+-${suffix}\.conf)/# \1/" /etc/nginx/conf.d/modsecurity/modsecurity.conf
  #  fi
  #done

  # Paranoia Level
  sed -z -E -i 's/#SecAction[^"]+"id:900000.*tx\.paranoia_level=1\"/SecAction \\\n  \"id:900000, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.paranoia_level='"${OPT_MODSEC_CRS_PARANOIA}"'\"/' "${setup_conf_path}"

  # Blocking Paranoia Level
  if [ -n "${OPT_MODSEC_CRS_BLOCKING_PARANOIA}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900000.*tx\.blocking_paranoia_level=1\"/SecAction \\\n  \"id:900000, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.blocking_paranoia_level='"${OPT_MODSEC_CRS_BLOCKING_PARANOIA}"'\"/' "${setup_conf_path}"
  fi

  # Executing Paranoia Level
  if [ -n "${OPT_MODSEC_CRS_EXECUTING_PARANOIA}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900001.*tx\.executing_paranoia_level=1\"/SecAction \\\n  \"id:900001, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.executing_paranoia_level='"${OPT_MODSEC_CRS_EXECUTING_PARANOIA}"'\"/' "${setup_conf_path}"
  fi

  # Detection Paranoia Level
  if [ -n "${OPT_MODSEC_CRS_DETECTION_PARANOIA}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900001.*tx\.detection_paranoia_level=1\"/SecAction \\\n  \"id:900001, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.detection_paranoia_level='"${OPT_MODSEC_CRS_DETECTION_PARANOIA}"'\"/' "${setup_conf_path}"
  fi

  # Enforce Body Processor URLENCODED
  if [ -n "${OPT_MODSEC_CRS_ENFORCE_BODYPROC_URLENCODED}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900010.*tx\.enforce_bodyproc_urlencoded=1\"/SecAction \\\n  \"id:900010, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.enforce_bodyproc_urlencoded='"${OPT_MODSEC_CRS_ENFORCE_BODYPROC_URLENCODED}"'\"/' "${setup_conf_path}"
  fi

  # Inbound and Outbound Anomaly Score
  sed -z -E -i 's/#SecAction[^"]+"id:900110.*tx\.outbound_anomaly_score_threshold=4\"/SecAction \\\n  \"id:900110, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.inbound_anomaly_score_threshold='"${OPT_MODSEC_CRS_ANOMALY_INBOUND}"',  \\\n   setvar:tx.outbound_anomaly_score_threshold='"${OPT_MODSEC_CRS_ANOMALY_OUTBOUND}"'\"/' "${setup_conf_path}"

  # HTTP methods that a client is allowed to use.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_METHODS}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900200.*\x27tx\.allowed_methods=[[:upper:][:space:]]*\x27\"/SecAction \\\n  \"id:900200, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_methods='"${OPT_MODSEC_CRS_ALLOWED_METHODS}"'\x27\"/' "${setup_conf_path}"
  fi

  # Content-Types that a client is allowed to send in a request.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE}" ]; then
    sed -z -E -i 's;#SecAction[^"]+"id:900220.*\x27tx\.allowed_request_content_type=[[:lower:][:space:]|+/-]*\x27\";SecAction \\\n  \"id:900220, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_request_content_type='"${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE}"'\x27\";' "${setup_conf_path}"
  fi

  # Content-Types charsets that a client is allowed to send in a request.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE_CHARSET}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900280.*\x27tx\.allowed_request_content_type_charset=[[:lower:][:digit:]|-]*\x27\"/SecAction \\\n  \"id:900280, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_request_content_type_charset='"${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE_CHARSET}"'\x27\"/' "${setup_conf_path}"
  fi

  # Allowed HTTP versions.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_HTTP_VERSIONS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900230.*\x27tx\.allowed_http_versions=[HTP012[:space:]/.]*\x27\"|SecAction \\\n  \"id:900230, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_http_versions='"${OPT_MODSEC_CRS_ALLOWED_HTTP_VERSIONS}"'\x27\"|' "${setup_conf_path}"
  fi

  # Forbidden file extensions.
  if [ -n "${OPT_MODSEC_CRS_RESTRICTED_EXTENSIONS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900240.*\x27tx\.restricted_extensions=[[:lower:][:space:]./]*\/\x27\"|SecAction \\\n  \"id:900240, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.restricted_extensions='"${OPT_MODSEC_CRS_RESTRICTED_EXTENSIONS}"'\x27\"|' "${setup_conf_path}"
  fi

  # Forbidden request headers.
  if [ -n "${OPT_MODSEC_CRS_RESTRICTED_HEADERS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900250.*\x27tx\.restricted_headers=[[:lower:][:space:]/-]*\x27\"|SecAction \\\n  \"id:900250, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.restricted_headers='"${OPT_MODSEC_CRS_RESTRICTED_HEADERS}"'\x27\"|' "${setup_conf_path}"
  fi

  # File extensions considered static files.
  if [ -n "${OPT_MODSEC_CRS_STATIC_EXTENSIONS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900260.*\x27tx\.static_extensions=/[[:lower:][:space:]/.]*\x27\"|SecAction \\\n  \"id:900260, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.static_extensions='"${OPT_MODSEC_CRS_STATIC_EXTENSIONS}"'\x27\"|' "${setup_conf_path}"
  fi

  # Block request if number of arguments is too high
  if [ "${OPT_MODSEC_CRS_MAX_NUM_ARGS}" ] && [[ "${OPT_MODSEC_CRS_MAX_NUM_ARGS}" =~ ^[\-0-9]+$ ]]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900300.*tx\.max_num_args=255\"/SecAction \\\n  \"id:900300, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.max_num_args='"${OPT_MODSEC_CRS_MAX_NUM_ARGS}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the length of any argument name is too high
  if [ -n "${OPT_MODSEC_CRS_ARG_NAME_LENGTH}" ] && [[ "${OPT_MODSEC_CRS_ARG_NAME_LENGTH}" =~ ^[\-0-9]+$ ]]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900310.*tx\.arg_name_length=100\"/SecAction \\\n \"id:900310, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.arg_name_length='"${OPT_MODSEC_CRS_ARG_NAME_LENGTH}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the length of any argument value is too high
  if [ -n "${OPT_MODSEC_CRS_ARG_LENGTH}" ] && [[ "${OPT_MODSEC_CRS_ARG_LENGTH}" =~ ^[\-0-9]+$ ]]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900320.*tx\.arg_length=400\"/SecAction \\\n  \"id:900320, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.arg_length='"${OPT_MODSEC_CRS_ARG_LENGTH}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the total length of all combined arguments is too high
  if [ -n "${OPT_MODSEC_CRS_TOTAL_ARG_LENGTH}" ] && [[ "${OPT_MODSEC_CRS_TOTAL_ARG_LENGTH}" =~ ^[\-0-9]+$ ]]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900330.*tx\.total_arg_length=64000\"/SecAction \\\n  \"id:900330, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n  t:none, \\\n   setvar:tx.total_arg_length='"${OPT_MODSEC_CRS_TOTAL_ARG_LENGTH}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the total length of all combined arguments is too high
  if [ -n "${OPT_MODSEC_CRS_MAX_FILE_SIZE}" ] && [[ "${OPT_MODSEC_CRS_MAX_FILE_SIZE}" =~ ^[\-0-9]+$ ]]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900340.*tx\.max_file_size=1048576\"/SecAction \\\n  \"id:900340, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.max_file_size='"${OPT_MODSEC_CRS_MAX_FILE_SIZE}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the total size of all combined uploaded files is too high
  if [ -n "${OPT_MODSEC_CRS_COMBINED_FILE_SIZES}" ] && [[ "${OPT_MODSEC_CRS_COMBINED_FILE_SIZES}" =~ ^[\-0-9]+$ ]]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900350.*tx\.combined_file_sizes=1048576\"/SecAction \\\n  \"id:900350, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.combined_file_sizes='"${OPT_MODSEC_CRS_COMBINED_FILE_SIZES}"'\"/' "${setup_conf_path}"
  fi

  # Activate UTF8 validation
  if [ -n "${OPT_MODSEC_CRS_VALIDATE_UTF8_ENCODING}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900950.*tx\.crs_validate_utf8_encoding=1\"/SecAction \\\n  \"id:900950, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.crs_validate_utf8_encoding=1\"/' "${setup_conf_path}"
  fi

  # Add SecDefaultActions
  if [ -n "${OPT_MODSEC_DEFAULT_PHASE1_ACTION}" ]; then
    sed -z -E -i "s/SecDefaultAction \"phase:1,log,auditlog,pass\"/SecDefaultAction \"${OPT_MODSEC_DEFAULT_PHASE1_ACTION}\"/" "${setup_conf_path}"
  fi

  if [ -n "${OPT_MODSEC_DEFAULT_PHASE2_ACTION}" ]; then
    sed -z -E -i "s/SecDefaultAction \"phase:2,log,auditlog,pass\"/SecDefaultAction \"${OPT_MODSEC_DEFAULT_PHASE2_ACTION}\"/" "${setup_conf_path}"
  fi

  # Substitute MODSEC_TAG
  if [ -n "${OPT_MODSEC_TAG}" ]; then
    sed -z -E -i "s/\\$\{MODSEC_TAG\}/${OPT_MODSEC_TAG}/g" "${setup_conf_path}"
  fi

  # Reporting Level
  if [ -n "${OPT_MODSEC_CRS_REPORTING_LEVEL}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900115.*tx\.reporting_level=2\"/SecAction \\\n  \"id:900115, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.reporting_level='"${OPT_MODSEC_CRS_REPORTING_LEVEL}"'\"/' "${setup_conf_path}"
  fi


  # Add marker rule for CRS test setup
  # Add it only once
  if [ -n "${OPT_MODSEC_CRS_ENABLE_TEST_MARKER}" ] && [ ${OPT_MODSEC_CRS_ENABLE_TEST_MARKER} -eq 1 ] && ! grep -q id:999999 "${setup_conf_path}"; then
    cat <<EOF >> "${setup_conf_path}"

    # Write the value from the X-CRS-Test header as a marker to the log
    SecRule REQUEST_HEADERS:X-CRS-Test "@rx ^.*$" \\
        "id:999999,\\
        phase:1,\\
        pass,\\
        t:none,\\
        log,\\
        msg:'%{MATCHED_VAR}',\
        ctl:ruleRemoveById=1-999999"
EOF
  fi
}

generate_maxmind() {
  if [ ! -z "${MAXMIND_LICENSE_KEY}" ]; then
    # Do not download if file is alreay present
    if [ ! -f "${MAXMIND_PATH}/maxmind.mmdb" ]; then
      if ! maxmind-ctl download --license-key=${MAXMIND_LICENSE_KEY} --edition=${MAXMIND_EDITION} --database=${MAXMIND_DATABASE} --db-path=${MAXMIND_PATH}; then
        LOG ERROR "Failed to download MaxMind database"
        exit 1
      fi
    fi
    # Generate the nginx config
    
  fi
}

command_initialize() {
  for dir in ${NGINX_CONF_PATH} ${NGINX_WEBROOT_PATH} ${NGINX_MODULES_PATH} ${NGINX_LOG_PATH} ${MODSEC_AUDIT_STORAGE}; do
    if [ ! -d "${dir}" ]; then
      LOG INFO "Creating directory   : ${dir}"
      mkdir -p ${dir}
    fi
    setgroup ${dir}
  done
}

command_configure() {
  if [ ! -f "${NGINX_CONF_PATH}/nginx.conf" ]; then
    LOG WARN "nginx.conf not found at ${NGINX_CONF_PATH}/nginx.conf. Copying default config"
    cp ${DEFAULT_CONFIGS_PATH}/nginx.conf ${NGINX_CONF_PATH}/nginx.conf
  fi
  generate_modules
  generate_maxmind
  generate_dhparams
  generate_whitelist
  generate_modsecurity
  # Done
}

command_test() {
  if ! nginx -t; then
    LOG ERROR "Failed to test nginx configuration"
    exit 1
  fi
}

command_reload() {
  local HASH_FILE=${NGINX_LOG_PATH}/.hash
  local CURRENT_HASH=
  local NEW_HASH=$(nginx -T | sha256sum | sed "s/ *\-$//")
  if [ -f "${HASH_FILE}" ]; then
    CURRENT_HASH=$(cat ${HASH_FILE})
  fi
  INFO "Current hash:               : ${CURRENT_HASH}"
  INFO "New hash:                   : ${NEW_HASH}"
  INFO "Force reload:               : ${FORCE}"
  if [ "${CURRENT_HASH}" != "${NEW_HASH}" ] || [ "${FORCE}" == 1 ]; then
    INFO "Hashes do not match, reloading nginx"
    if ! nginx -s reload; then
      LOG ERROR "NGINX could not be restarted!"
      exit 1
    fi
    echo "${NEW_HASH}" > "${HASH_FILE}"
  else
    INFO "Hashes match, not reloading nginx"
  fi
}

command_add() {
    local SITE_NAME=$1
    local ALT_DOMAINS=$2
    local CERT_FILE=$3
    local KEY_FILE=$4
    local CA_CERT=$5
    local SITE_CONF="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf"
    local SITE_ROOT="${NGINX_WEBROOT_PATH}/${SITE_NAME}"
    local LOG_PATH="${NGINX_LOG_PATH}/${SITE_NAME}"
    local CACHE_PATH="${NGINX_CACHE_PATH}/${SITE_NAME}"
    # Create the direcrtoies
    for dir in ${SITE_ROOT} ${LOG_PATH} ${CACHE_PATH}; do
      if [ ! -d "${dir}" ]; then
        LOG INFO "Creating directory   : ${dir}"
        mkdir -p ${dir}
      fi
      setgroup ${dir}
    done
    # Create the site config from template
    LOG INFO "Creating site config : ${SITE_CONF}"
    envsubst '$SITE_NAME $SITE_ROOT $LOG_PATH $CACHE_PATH $CERT_FILE $KEY_FILE $CA_CERT $ALT_DOMAINS' < /templates/site.conf.template > "${SITE_CONF}"
    # Enable few items basis settings
    if [ "${OPT_WITH_MODSECURITY}" == "1" ]; then
      sed -i -E "s/#\s*include\s*modsecurity.conf;/include modsecurity.conf;/" "${SITE_CONF}"
    elif [ "${OPT_WITH_MODSECURITY}" == "2" ]; then
      sed -i -E "s/#\s*include\s*modsecurity.conf;/include modsecurity-override.conf;/" "${SITE_CONF}"
    fi
    
    # Enable SSL correctly
    if [ "${SSL_ENABLED}" == 1 ];
    then
      DEBUG "Updating config to enable ssl"
      sed -i 's|#listen                         443 ssl;|listen                         443 ssl;|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
      sed -i 's|#listen                         \[::\]:443 ssl;|listen                         [::]:443 ssl;|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
      sed -i 's|#ssl_certificate                /etc/nginx/certs/$server_name.crt;|ssl_certificate                /etc/nginx/certs/'"${OPT_CERT_FILE}"';|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
      sed -i 's|#ssl_certificate_key            /etc/nginx/certs/$server_name.key;|ssl_certificate_key            /etc/nginx/certs/'"${OPT_CERT_KEY}"';|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
      sed -i 's|#add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload" always;|add_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload" always;|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
      if [ "${SSL_STAPLING_ENABLED}" == 1 ]; then
        DEBUG "Enabling SSL stapling"
        sed -i 's|#ssl_stapling                   on;|ssl_stapling                   on;|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
        sed -i 's|#ssl_stapling_verify            on;|ssl_stapling_verify            on;|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
        sed -i 's|#ssl_trusted_certificate        /etc/nginx/certs/$server_name_ca.crt;|ssl_trusted_certificate        /etc/nginx/certs/'"${OPT_CA_CERT}"';|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
      fi
      sed -i 's|#include /etc/nginx/conf.d/https-redirect.conf;|include /etc/nginx/conf.d/https-redirect.conf;|' ${NGINX_SITE_PATH}/${OPT_PRIMARY_DOMAIN}.conf
    fi
    # Reload nginx
    command_reload
}

command_list() {
  # Find all files in sites.d where extension is .conf or .conf.disabled
  for file in $(find ${NGINX_CONF_PATH}/sites.d -type f -name "*.conf*" -printf "%f\n"); do
    # if extension is .conf.disabled, it is a disabled site
    if [[ "${file}" == *.conf.disabled ]]; then
      LOG INFO "${file}                 : Disabled"
    else
      LOG INFO "${file}                 : Enabled"
    fi
  done
}

command_disable() {
  local SITE_NAME=$1
  local SITE_CONF="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf"
  local SITE_CONF_DISABLED="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf.disabled"
  if [ ! -f ${SITE_CONF} ] && [ ! -f ${SITE_CONF_DISABLED} ]; then
    LOG ERROR "Site ${SITE_NAME} does not exist"
    exit 1
  fi
  if [ -f SITE_CONF_DISABLED ]; then
    LOG INFO "Site ${SITE_NAME} is already disabled"
    exit 0
  fi
  mv ${SITE_CONF} ${SITE_CONF_DISABLED}
  command_reload
}

command_enable() {
  local SITE_NAME=$1
  local SITE_CONF="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf"
  local SITE_CONF_DISABLED="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf.disabled"
  if [ ! -f ${SITE_CONF} ] && [ ! -f ${SITE_CONF_DISABLED} ]; then
    LOG ERROR "Site ${SITE_NAME} does not exist"
    exit 1
  fi
  if [ -f SITE_CONF ]; then
    LOG INFO "Site ${SITE_NAME} is already enabled"
    exit 0
  fi
  mv ${SITE_CONF_DISABLED} ${SITE_CONF}
  command_reload
}

command_remove() {
  local SITE_NAME=$1
  local SITE_CONF="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf"
  local SITE_CONF_DISABLED="${NGINX_CONF_PATH}/sites.d/${SITE_NAME}.conf.disabled"
  if [ ! -f ${SITE_CONF} ] && [ ! -f ${SITE_CONF_DISABLED} ]; then
    LOG ERROR "Site ${SITE_NAME} does not exist"
    exit 1
  fi
  rm -f ${SITE_CONF} ${SITE_CONF_DISABLED}
  # Delete webroot
  rm -rf ${NGINX_WEBROOT_PATH}/${SITE_NAME}
  command_reload
}


# Parse options
COMMAND=$1
if [ -z "$COMMAND" ]; then
  usage
  exit 1
fi
shift  # shift off the command for getopts

OPT_MODSECURITY=0
OPT_CERT_FILE=
OPT_CERT_KEY=
OPT_CA_CERT=

if ! args="$(getopt -o hd: --long help,domain:,cert-file:,cert-key:,ca-cert-file:,with-modsecurity,custom-modsecurity,debug -n "$ARG0" -- "$@")"; then
  usage
  exit 1
fi

set -- $args
while [ "$#" -gt 0 ]; do
  arg="$1"
  shift
  case "$arg" in
    -h | --help)
      usage
      exit 0
      ;;
    --debug)
      DEBUG=1
      ;;
    -d | --domain)
      if [ "${1//\'/}" == "" ]; then
        ERROR "Domain cannot be empty"
      fi
      if [ "${1//\'/}" == "acme" ] || [ "${1//\'/}" == "default" ]; then
        ERROR "Invalid/Reserved domain name ${1//\'/}"
      fi
      # Check if the domain is valid
      if ! echo "${1//\'/}" | grep -qE '^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'; then
        ERROR "Invalid domain name ${1//\'/}"
      fi
      if [ -z "${OPT_PRIMARY_DOMAIN}" ]; then
        OPT_PRIMARY_DOMAIN=${1//\'/}
        OPT_DOMAINS="${1//\'/}"
      else
        OPT_DOMAINS="${OPT_DOMAINS} ${1//\'/}"
      fi
      shift
      ;;
    --with-modsecurity)
      OPT_WITH_MODSECURITY=1
      ;;
    --custom-modsecurity)
      OPT_WITH_MODSECURITY=2
      ;;
    --cert-file)
      OPT_CERT_FILE=${1//\'/}
      shift
      ;;
    --cert-key)
      OPT_CERT_KEY=${1//\'/}
      shift
      ;;
    --ca-cert)
      OPT_CA_CERT=${1//\'/}
      shift
      ;;
    --)
      break
      ;;
    *)
      ERROR "Unknown argument '$arg' when parsing script arguments."
      exit 1
      ;;
  esac
done

# Main script execution
LOG DEBUG "Script started."

# Execute command
case "$COMMAND" in
  rotate) command_rotate;;
  purge) command_purge;;
  *) LOG ERROR "Invalid command: $COMMAND"; usage; exit 1;;
esac

LOG DEBUG "Script finished."

# Remove lock file
rm -f "${LOCKFILE}"
trap - INT TERM EXIT

#!/bin/sh
LOCKFILE=/var/log/nginx/nginx-ctl.lock

# Load Defaults from config
source /app/config.sh

# NGINX_MODULES_PATH=/usr/local/nginx/modules
# NGINX_CONF_DIR=/etc/nginx

OPT_FORCE=0
OPT_DEBUG=0
OPT_PRIMARY_DOMAIN=
OPT_DOMAINS=
# SSL Options
OPT_SSL_KEY_LENGTH=4096
OPT_SSL_MODE=auto
OPT_SSL_EMAIL=${ACME_EMAIL}
OPT_SSL_SERVER=${ACME_SERVER:-letsencrypt}
# MaxMind Options
OPT_MAXMIND_KEY=${MAXMIND_KEY}
OPT_MAXMIND_EDITION=${MAXMIND_EDITION:-geoip2lite}
OPT_MAXMIND_DATABASE=${MAXMIND_DATABASE:-city}
# NGINX Options
OPT_NGINX_WHITELIST_IP=${NGINX_WHITELIST_IP}

print_message() {
  local message_type=$1
  local message=$2
  local color_code
  local dt=$(date --utc +%FT%TZ)
  local host=$(hostname)
  case $message_type in
  ERROR) color_code='\033[0;31m' ;;
  WARN) color_code='\033[0;33m' ;;
  DEBUG) color_code='\033[1;32m' ;;
  INFO) color_code='\033[0;36m' ;;
  esac

  printf "[${dt}@${host}]${color_code}[${message_type}]: ${message}\033[0m\n"
}

ERROR() {
  print_message "ERROR" "$1"
  cleanup
  exit 1
}

WARN() {
  print_message "WARN" "$1"
}

DEBUG() {
  [ "$DEBUG_MODE" = 1 ] && print_message "DEBUG" "$1"
}

INFO() {
  print_message "INFO" "$1"
}

# Config management
# This script contains a base config file (JSON) where 
# script defaults are mentioned. This can be dynamically edited 
# from nginx-cc project (comming soon). Idea is to have a centralised management 
# infrastructure to manage configurations. However we do not want to loose 
# indipendant functionality of the nginx server

# Load from config
config_load() {
  echo "Not Implemented"
}

# Save to config file
config_save() {
  echo "Not Implemented"
}

init() {
  if [ -f ${LOCKFILE} ]; then
    INFO "There is already an instance of this script running. Exiting..."
    exit 1
  fi
  touch ${LOCKFILE}
}

cleanup() {
  if [ -f ${LOCKFILE} ]; then
    rm -f ${LOCKFILE}
  fi
}

usage() {
  echo "Usage: ${0} COMMAND [OPTIONS]"
  echo
  echo "Script to manage NGINX configuration"
  echo
  echo "Commands:"
  echo
  echo "###############################################################################"
  echo "#                                 NGINX                                       #"
  echo "###############################################################################"
  echo
  echo "  configure                       Configure base nginx server"
  echo
  echo "  add-site                        Add new site"
  echo "    Options:"
  echo "      -d, --domain <TLD>          The domain for which to create the site. If multiple domains are specified, then the first domain will be used as the primary domain"
  echo "          --ssl-mode <SSL_MODE>   SSL Mode to be used, auto, none, acme, self"
  echo "          --with-modsecurity      Enable modsecurity with default rules on this site"
  echo "          --upstream-service      The docker service this domain uses as upstream"
  echo "          --upstream-label        The docker label this domain uses as upstream"
  echo "          --upstream-ip           List of IP address to use as upstream"
  echo "          --upstream-port         The docker port this domain uses as upstream"
  echo "          --upstream-weight       The docker weight this domain uses as upstream"
  echo "          --upstream-fail-timeout The docker fail timeout this domain uses as upstream"
  echo "          --upstream-max-fails    The docker max fails this domain uses as upstream"
  echo
  echo "  list-sites                      List all sites"
  echo
  echo "  enable-site                     Renew certificate. If domain is not specified, then all certificates will be renewed"
  echo "    Options:"
  echo "      -d, --domain <TLD>          The domain to be enabled. The primary domain should be passed. Passing alternate domain will throw error"
  echo "                                  If no domain is specified then all sites will be enabled"
  echo
  echo "  disable-site                    Renew certificate. If domain is not specified, then all certificates will be renewed"
  echo "    Options:"
  echo "      -d, --domain <TLD>          The domain to be disabled. The primary domain should be passed. Passing alternate domain will throw error"
  echo "                                  If no domain is specified then all sites will be enabled"
  echo
  echo "  reload                          Reload nginx configuration"
  echo
  echo "###############################################################################"
  echo "#                                    SSL                                      #"
  echo "###############################################################################"
  echo
  echo "  acme-register"
  echo "    Options:"
  echo "      -e, --email <EMAIL>         The email address to be used for registration"
  echo "      -s, --server <SERVER>       The server with which to register, default is letsencrypt"
  echo
  echo "  ssl-generate                    Generate SSL certificate"
  echo "    Options:"
  echo "      -d, --domain <TLD>          The domain for which to create the SSL. If multiple domains are specified, then the first domain will be used as the primary domain"
  echo "          --ssl-mode <SSL_MODE>   SSL Mode to be used, auto, none, acme, self. Defaults to auto"
  echo "          --server <SERVER>       The server with which to register, default is letsencrypt"
  echo "          --output <DIR>          Output directory to store certificates"
  echo
  echo "  ssl-renew                       Renew certificate. If domain is not specified, then all certificates will be renewed"
  echo "    Options:"
  echo "      -d, --domain <TLD>          The domain for which to renew."
  echo 
  echo "###############################################################################"
  echo "#                                  MaxMind                                    #"
  echo "###############################################################################"
  echo
  echo "  maxmind-download                Download MaxMind database"
  echo "    Options:"
  echo "          --key <KEY>             The MaxMind license key"
  echo "          --edition <EDITION>     The MaxMind edition to download, defaults to geoip2lite"
  echo "          --database <DATABASE>   The MaxMind database to download, defaults to city"
  echo
  echo "Options:"
  echo "  -h, --help                      Show this help message and exit"
  echo "  -c, --config <FILE>             The configuration file to use"
  echo "      --debug                     Enable debug messages to be displayed"
  echo
}

configure_modsecurity() {
  DEBUG "Generating Modsecurity config"
  # Set override file
  # envsubst < /templates/modsecurity-override.conf.template > /etc/nginx/conf.d/modsecurity/modsecurity-override.conf
  DEBUG "Setup overrides"
  envsubst < /templates/modsecurity-override.conf.template > /tmp/modsecurity-override.conf
  
  # Lets build owasp
  cp /templates/crs-setup.conf.template /tmp/crs-setup.conf
  # local setup_conf_path="/etc/nginx/conf.d/modsecurity/owasp/crs-setup.conf"
  local setup_conf_path="/tmp/crs-setup.conf"
  
  DEBUG "Modsecurity OWASP Configuration"
  # Check if crs-setup.conf is overriden
  # if [ -n "${MANUAL_MODE}" ]; then
  #   echo "Using manual config mode"
  #   return; # Don't use exit on a sourced script
  # fi

  # Plugins can be disabled entirely by setting CRS_DISABLE_PLUGINS.
  if [ -n "${OPT_MODSEC_CRS_DISABLE_PLUGINS}" ]; then
      echo "Plugins will be disabled"
      return; # Don't use exit on a sourced script
  fi

  # Handle plugins if we have the files.
  # Note: we are careful here to not assume the existance of the "plugins"
  # directory. It is being introduced with version 4 of CRS.
  DEBUG "Modsecurity OWASP Enable pluginx"
  for suffix in "config" "before" "after"; do
      if [ -n "$(find /etc/nginx/conf.d/modsecurity/owasp -path "/etc/nginx/conf.d/modsecurity/owasp/plugins/*-${suffix}.conf")" ]; then
          # enable if there are config files
          sed -i -E "s/^#\s*(.+-${suffix}\.conf)/\1/" /etc/nginx/conf.d/modsecurity/modsecurity.conf
      else
          # disable if there are no config files
          sed -i -E "s/^([^#]+-${suffix}\.conf)/# \1/" /etc/nginx/conf.d/modsecurity/modsecurity.conf
      fi
  done

  # Check if crs-setup.conf is overriden
  # if [ -n "${MANUAL_MODE}" ]; then
  #   echo "Using manual config mode"
  #   return; # Don't use exit on a sourced script
  # fi

  # Paranoia Level
  sed -z -E -i 's/#SecAction[^"]+"id:900000.*tx\.paranoia_level=1\"/SecAction \\\n  \"id:900000, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.paranoia_level='"${OPT_MODSEC_CRS_PARANOIA}"'\"/' "${setup_conf_path}"

  # Blocking Paranoia Level
  if [ -n "${OPT_MODSEC_CRS_BLOCKING_PARANOIA}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900000.*tx\.blocking_paranoia_level=1\"/SecAction \\\n  \"id:900000, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.blocking_paranoia_level='"${OPT_MODSEC_CRS_BLOCKING_PARANOIA}"'\"/' "${setup_conf_path}"
  fi

  # Executing Paranoia Level
  if [ -n "${OPT_MODSEC_CRS_EXECUTING_PARANOIA}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900001.*tx\.executing_paranoia_level=1\"/SecAction \\\n  \"id:900001, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.executing_paranoia_level='"${OPT_MODSEC_CRS_EXECUTING_PARANOIA}"'\"/' "${setup_conf_path}"
  fi

  # Detection Paranoia Level
  if [ -n "${OPT_MODSEC_CRS_DETECTION_PARANOIA}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900001.*tx\.detection_paranoia_level=1\"/SecAction \\\n  \"id:900001, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.detection_paranoia_level='"${OPT_MODSEC_CRS_DETECTION_PARANOIA}"'\"/' "${setup_conf_path}"
  fi

  # Enforce Body Processor URLENCODED
  if [ -n "${OPT_MODSEC_CRS_ENFORCE_BODYPROC_URLENCODED}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900010.*tx\.enforce_bodyproc_urlencoded=1\"/SecAction \\\n  \"id:900010, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.enforce_bodyproc_urlencoded='"${OPT_MODSEC_CRS_ENFORCE_BODYPROC_URLENCODED}"'\"/' "${setup_conf_path}"
  fi

  # Inbound and Outbound Anomaly Score
  sed -z -E -i 's/#SecAction[^"]+"id:900110.*tx\.outbound_anomaly_score_threshold=4\"/SecAction \\\n  \"id:900110, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.inbound_anomaly_score_threshold='"${OPT_MODSEC_CRS_ANOMALY_INBOUND}"',  \\\n   setvar:tx.outbound_anomaly_score_threshold='"${OPT_CMODSEC_RS_ANOMALY_OUTBOUND}"'\"/' "${setup_conf_path}"

  # HTTP methods that a client is allowed to use.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_METHODS}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900200.*\x27tx\.allowed_methods=[[:upper:][:space:]]*\x27\"/SecAction \\\n  \"id:900200, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_methods='"${OPT_MODSEC_CRS_ALLOWED_METHODS}"'\x27\"/' "${setup_conf_path}"
  fi

  # Content-Types that a client is allowed to send in a request.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE}" ]; then
    sed -z -E -i 's;#SecAction[^"]+"id:900220.*\x27tx\.allowed_request_content_type=[[:lower:][:space:]|+/-]*\x27\";SecAction \\\n  \"id:900220, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_request_content_type='"${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE}"'\x27\";' "${setup_conf_path}"
  fi

  # Content-Types charsets that a client is allowed to send in a request.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE_CHARSET}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900280.*\x27tx\.allowed_request_content_type_charset=[[:lower:][:digit:]|-]*\x27\"/SecAction \\\n  \"id:900280, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_request_content_type_charset='"${OPT_MODSEC_CRS_ALLOWED_REQUEST_CONTENT_TYPE_CHARSET}"'\x27\"/' "${setup_conf_path}"
  fi

  # Allowed HTTP versions.
  if [ -n "${OPT_MODSEC_CRS_ALLOWED_HTTP_VERSIONS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900230.*\x27tx\.allowed_http_versions=[HTP012[:space:]/.]*\x27\"|SecAction \\\n  \"id:900230, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.allowed_http_versions='"${OPT_MODSEC_CRS_ALLOWED_HTTP_VERSIONS}"'\x27\"|' "${setup_conf_path}"
  fi

  # Forbidden file extensions.
  if [ -n "${OPT_MODSEC_CRS_RESTRICTED_EXTENSIONS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900240.*\x27tx\.restricted_extensions=[[:lower:][:space:]./]*\/\x27\"|SecAction \\\n  \"id:900240, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.restricted_extensions='"${OPT_MODSEC_CRS_RESTRICTED_EXTENSIONS}"'\x27\"|' "${setup_conf_path}"
  fi

  # Forbidden request headers.
  if [ -n "${OPT_MODSEC_CRS_RESTRICTED_HEADERS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900250.*\x27tx\.restricted_headers=[[:lower:][:space:]/-]*\x27\"|SecAction \\\n  \"id:900250, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.restricted_headers='"${OPT_MODSEC_CRS_RESTRICTED_HEADERS}"'\x27\"|' "${setup_conf_path}"
  fi

  # File extensions considered static files.
  if [ -n "${OPT_MODSEC_CRS_STATIC_EXTENSIONS}" ]; then
    sed -z -E -i 's|#SecAction[^"]+"id:900260.*\x27tx\.static_extensions=/[[:lower:][:space:]/.]*\x27\"|SecAction \\\n  \"id:900260, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:\x27tx.static_extensions='"${OPT_MODSEC_CRS_STATIC_EXTENSIONS}"'\x27\"|' "${setup_conf_path}"
  fi

  # Block request if number of arguments is too high
  if [ -n "${OPT_MODSEC_CRS_MAX_NUM_ARGS}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900300.*tx\.max_num_args=255\"/SecAction \\\n  \"id:900300, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.max_num_args='"${OPT_MODSEC_CRS_MAX_NUM_ARGS}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the length of any argument name is too high
  if [ -n "${OPT_MODSEC_CRS_ARG_NAME_LENGTH}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900310.*tx\.arg_name_length=100\"/SecAction \\\n \"id:900310, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.arg_name_length='"${OPT_MODSEC_CRS_ARG_NAME_LENGTH}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the length of any argument value is too high
  if [ -n "${OPT_MODSEC_CRS_ARG_LENGTH}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900320.*tx\.arg_length=400\"/SecAction \\\n  \"id:900320, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.arg_length='"${OPT_MODSEC_CRS_ARG_LENGTH}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the total length of all combined arguments is too high
  if [ -n "${OPT_MODSEC_CRS_TOTAL_ARG_LENGTH}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900330.*tx\.total_arg_length=64000\"/SecAction \\\n  \"id:900330, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n  t:none, \\\n   setvar:tx.total_arg_length='"${OPT_MODSEC_CRS_TOTAL_ARG_LENGTH}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the total length of all combined arguments is too high
  if [ -n "${OPT_MODSEC_CRS_MAX_FILE_SIZE}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900340.*tx\.max_file_size=1048576\"/SecAction \\\n  \"id:900340, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.max_file_size='"${OPT_MODSEC_CRS_MAX_FILE_SIZE}"'\"/' "${setup_conf_path}"
  fi

  # Block request if the total size of all combined uploaded files is too high
  if [ -n "${OPT_MODSEC_CRS_COMBINED_FILE_SIZES}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900350.*tx\.combined_file_sizes=1048576\"/SecAction \\\n  \"id:900350, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.combined_file_sizes='"${OPT_MODSEC_CRS_COMBINED_FILE_SIZES}"'\"/' "${setup_conf_path}"
  fi

  # Activate UTF8 validation
  if [ -n "${OPT_MODSEC_CRS_VALIDATE_UTF8_ENCODING}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900950.*tx\.crs_validate_utf8_encoding=1\"/SecAction \\\n  \"id:900950, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.crs_validate_utf8_encoding=1\"/' "${setup_conf_path}"
  fi

  # Add SecDefaultActions
  if [ -n "${OPT_MODSEC_DEFAULT_PHASE1_ACTION}" ]; then
    sed -z -E -i "s/SecDefaultAction \"phase:1,log,auditlog,pass\"/SecDefaultAction \"${OPT_MODSEC_DEFAULT_PHASE1_ACTION}\"/" "${setup_conf_path}"
  fi

  if [ -n "${OPT_MODSEC_DEFAULT_PHASE2_ACTION}" ]; then
    sed -z -E -i "s/SecDefaultAction \"phase:2,log,auditlog,pass\"/SecDefaultAction \"${OPT_MODSEC_DEFAULT_PHASE2_ACTION}\"/" "${setup_conf_path}"
  fi

  # Substitute MODSEC_TAG
  if [ -n "${OPT_MODSEC_TAG}" ]; then
    sed -z -E -i "s/\\$\{MODSEC_TAG\}/${OPT_MODSEC_TAG}/g" "${setup_conf_path}"
  fi

  # Reporting Level
  if [ -n "${OPT_MODSEC_CRS_REPORTING_LEVEL}" ]; then
    sed -z -E -i 's/#SecAction[^"]+"id:900115.*tx\.reporting_level=2\"/SecAction \\\n  \"id:900115, \\\n   phase:1, \\\n   nolog, \\\n   pass, \\\n   t:none, \\\n   setvar:tx.reporting_level='"${OPT_MODSEC_CRS_REPORTING_LEVEL}"'\"/' "${setup_conf_path}"
  fi


  # Add marker rule for CRS test setup
  # Add it only once
  if [ -n "${OPT_MODSEC_CRS_ENABLE_TEST_MARKER}" ] && [ ${OPT_MODSEC_CRS_ENABLE_TEST_MARKER} -eq 1 ] && ! grep -q id:999999 "${setup_conf_path}"; then
    cat <<EOF >> "${setup_conf_path}"

    # Write the value from the X-CRS-Test header as a marker to the log
    SecRule REQUEST_HEADERS:X-CRS-Test "@rx ^.*$" \\
        "id:999999,\\
        phase:1,\\
        pass,\\
        t:none,\\
        log,\\
        msg:'%{MATCHED_VAR}',\
        ctl:ruleRemoveById=1-999999"
EOF
  fi
}

# Configure the base NGINX server
command_configure() {
  WARN "Running nginx configuration command. This should be run only at start of container."
  # Add modules to the config
  DEBUG "Begin Configuration of NGINX"
  rm -rf /tmp/*.conf
  DEBUG "Generating load modules statements basis availability in ${NGINX_MODULES_PATH}"
  echo "load_module ${NGINX_MODULES_PATH}/ngx_stream_module.so;" >> /tmp/modules.conf
  # We add Stream first
  for file in ${NGINX_MODULES_PATH}/*.so; do
    if [ "$file" != "${NGINX_MODULES_PATH}/ngx_stream_module.so" ]; then
      echo "load_module ${file};" >> /tmp/modules.conf
    fi
  done

  # Move Maxmind conf
  if [ ! -z "${OPT_MAXMIND_KEY}" ]; then
    command_maxmind_fetch
    if [ ! -f ${MAXMIND_PATH}/maxmind.mmdb ]; then
      DEBUG "Generating maxmind.conf using maxming.conf.template"
      if [ ${OPT_MAXMIND_DATABASE} == 'city' ]; then
        mv /etc/nginx/conf.d/maxmind-city.conf /tmp/maxmind.conf
      elif [ ${OPT_MAXMIND_DATABASE} == 'country' ]; then
        mv /etc/nginx/conf.d/maxmind-country.conf /tmp/maxmind.conf
      fi
    fi
  fi

  # ACME
  if [ ! -z "$OPT_ACME_EMAIL" ]; then
    command_acme_register
  fi
  # Create the file
  if [ ! -z "${OPT_ACME_THUMBPRINT}" ]; then
    envsubst '$OPT_ACME_THUMBPRINT' < /templates/acme-stateless.conf > /tmp/acme-stateless.conf
  fi
  # ModSecurity
  configure_modsecurity

  # Generate dhparam
  if [ ! -f "/etc/nginx/dhparam.pem" ]; 
  then
    DEBUG "Generating dhparam for ${OPT_SSL_KEY_LENGTH} bits"
    openssl dhparam -dsaparam -out /tmp/dhparam.pem ${OPT_SSL_KEY_LENGTH};
  fi

  # Whitelist IP address
  if [ ! -z "${OPT_NGINX_WHITELIST_IP}" ]; then
    DEBUG "Adding whitelist IP address"
    # OPT_NGINX_WHITELIST_IP is a comma seperated list of IP addresses, loop throw and add
    for ip in $(echo ${OPT_NGINX_WHITELIST_IP} | sed "s/,/ /g"); do
      echo "allow ${ip};" >> /tmp/whitelist.conf
    done
  fi
  # Generate base nginx.conf
  envsubst < /templates/nginx.conf.template > /tmp/nginx.conf

  # If we have gotten this far, then we can replace the nginx.conf
  DEBUG "Below config files generated: "
  DEBUG "Modules                  : Modules to be initiated"
  DEBUG "modsecurity-override     : ModSecurity overrides"
  DEBUG "OWASP/crs-setup          : Core Rule Set file"
  DEBUG "dhparam                  : DHPPARAMS file for SSL with key length ${OPT_SSL_KEY_LENGTH}"
  DEBUG "Whitelist                : List of IP Address to be whitelisted"
  if [ -f /tmp/maxmind.conf ]; then
    DEBUG "Maxmind                  : Maxmind configuration"
  fi
  if [ -f /tmp/acme-stateless.conf ]; then
    DEBUG "ACME-Stateless           : ACME Stateless configuration"
  fi
  DEBUG "Nginx                    : Nginx config"
  mv -f /tmp/modules.conf ${NGINX_CONF_PATH}/conf.d/modules.conf
  mv -f /tmp/modsecurity-override.conf ${NGINX_CONF_PATH}/conf.d/modsecurity/modsecurity-override.conf
  mv -f /tmp/crs-setup.conf ${NGINX_CONF_PATH}/conf.d/modsecurity/owasp/crs-setup.conf
  mv -f /tmp/dhparam.pem ${NGINX_CONF_PATH}/dhparam.pem
  mv -f /tmp/whitelist.conf ${NGINX_CONF_PATH}/conf.d/whitelist.conf
  if [ -f /tmp/maxmind.conf ]; then
    # Enable maxmind
    sed -i 's|#include /etc/nginx/conf.d/maxmind.conf;|include /etc/nginx/conf.d/maxmind.conf;|' /tmp/nginx.conf
    mv -f /tmp/maxmind.conf ${NGINX_CONF_PATH}/conf.d/maxmind.conf
  fi
  if [ -f /tmp/acme-stateless.conf ]; then
    mv -f /tmp/acme-stateless.conf ${NGINX_CONF_PATH}/conf.d/acme-stateless.conf
    # Enable in nginx.conf
    sed -i 's|#include /etc/nginx/conf.d/acme-stateless.conf;|include /etc/nginx/conf.d/acme-stateless.conf;|' /tmp/nginx.conf
  fi
  mv -f /tmp/nginx.conf ${NGINX_CONF_PATH}/nginx.conf

  # Test the config
  if ! nginx -t; then
    ERROR "Failed to validate NGINX config"
  fi
  # We dont perform a reload as it is possible it is being called on boot
}

# Refreshes/Reloads NGINX using latest config
command_reload() {
  local CONFIG_HASH=$(nginx -T | sha512sum | sed "s/ *\-$//")
  local HASH_FILE=/tmp/nginx.hash
  local CURRENT_HASH=
  if [ -f "${HASH_FILE}" ]; then
    # Load the value
    CURRENT_HASH=$(cat ${HASH_FILE})
  fi
  DEBUG "Config Hash    : ${CONFIG_HASH}"
  DEBUG "Current Hash   : ${CURRENT_HASH}"
  DEBUG "Force Flag     : ${OPT_FORCE}"
  if [ "$CURRENT_HASH" != $CONFIG_HASH ] || [ "$OPT_FORCE" == 1 ]; then
    # Ok Validate the new config
    if [ $(nginx -t) -eq 0 ]; then
      # Config is valid, lets reload
      if ! nginx -s reload; then
        ERROR "Failed to reload NGINX config"
      fi
      # Remove old file
      rm -f ${HASH_FILE}
      echo $CONFIG_HASH > ${HASH_FILE}
    else
      # Config is not valid, lets ignore
      ERROR "NGINX config is not valid. Ignoring changes..."
    fi
  fi
}

command_add_site() {
  echo "Not Implemented"
}

command_disable_site() {
  local DOMAIN=${OPT_DOMAIN}
  local DOMAIN_FILE=/etc/nginx/sites.d/${DOMAIN}.conf
  if [ -f ${DOMAIN_FILE} ]; then
    mv ${DOMAIN_FILE} /etc/nginx/sites.d/${DOMAIN}.conf.disabled
  else
    ERROR "Site ${DOMAIN} is not enabled"
  fi
}

command_enable_site() {
  local DOMAIN=${OPT_DOMAIN}
  local DOMAIN_FILE=/etc/nginx/sites.d/${DOMAIN}.conf.disabled
  if [ -f ${DOMAIN_FILE} ]; then
    mv ${DOMAIN_FILE} /etc/nginx/sites.d/${DOMAIN}.conf
  else
    ERROR "Site ${DOMAIN} is not disabled"
  fi
}

command_list_sites() {
  for file in /etc/nginx/sites.d/*.conf; do
    echo $(basename $file)
  done
}

# Upstream Management
command_add_upstream() {
  echo "Not Implemented"
}

command_remove_upstream() {
  echo "Not Implemented"
}

command_update_upstream() {
  echo "Not Implemented"
}

command_list_upstreams() {
  echo "Not Implemented"
}

# SSL Management
callAcme() {
  /app/acme/acme.sh --home ${ACME_HOME} --config-home ${ACME_HOME} "$@"
  return $?
}

command_acme_register() {
  local EMAIL=${OPT_ACME_EMAIL}
  local SERVER=${OPT_ACME_SERVER}
  if [ ! -z ${EMAIL} ];
  then
    DEBUG "Registering ACME Account with email ${EMAIL} and server ${SERVER}"
    output=$(acme --register-account --server ${SERVER} -m ${EMAIL})
    # Extract the value of ACCOUNT_THUMBPRINT from the output using grep and awk
    OPT_ACME_THUMBPRINT=$(echo "$output" | grep "ACCOUNT_THUMBPRINT" | awk -F "'" '{print $2}')
    if -z OPT_ACME_THUMBPRINT; then
      ERROR "Registration failed for email ${EMAIL} in ${SERVER}!"
    fi
    DEBUG "Registered ACME Account with email ${EMAIL} and server ${SERVER}. Received thumbprint - ${OPT_ACME_THUMBPRINT}"
  else
    ERROR "Email id is required for registration"
  fi
}

command_ssl_issue() {
  echo "Not Implemented"
}

command_ssl_renew() {
  echo "Not Implemented"
}

# Maxmind
download_maxmind() {
  local KEY=${1:-$OPT_MAXMIND_KEY}
  local EDITION=${2:-$OPT_MAXMIND_EDITION}
  local DATABASE=${3:-$OPT_MAXMIND_DATABASE}
  if [ "${EDITION}" == 'geolite2' ]; then
    EDITION='GeoLite2'
  fi
  if [ "${DATABASE}" == 'country' ]; then
    DATABASE='Country'
  fi
  if [ -z "${KEY}" ]; then
    ERROR "Missing Maxmind licence key"
  fi
  INFO "Downloading ${EDITION}-${DATABASE} database"
  DOWNLOAD_FILE="${EDITION}-${DATABASE}"
  DOWNLOAD_URL="https://download.maxmind.com/app/geoip_download?edition_id=${DOWNLOAD_FILE}&license_key=${KEY}&suffix=tar.gz"
  DEBUG "Downloading ${DOWNLOAD_FILE} from ${DOWNLOAD_URL}"
  mkdir -p /tmp/maxmind
  if ! wget ${DOWNLOAD_URL} -O /tmp/${DOWNLOAD_FILE}.tar.gz; then
    ERROR "Failed to download ${DOWNLOAD_FILE} from ${DOWNLOAD_URL}"
  fi
  if ! tar -xf /tmp/${DOWNLOAD_FILE}.tar.gz -C /tmp/maxmind --strip-components 1; then
    ERROR "Failed to extract ${DOWNLOAD_FILE}.tar.gz"
  fi
  rm /tmp/${DOWNLOAD_FILE}.tar.gz
  # Rename
  mv /tmp/maxmind/${DOWNLOAD_FILE}.mmdb /tmp/maxmind/maxmind.mmdb
  # Take backup of existing file
  if [ -f "${MAXMIND_PATH}/maxmind.mmdb" ] && [ ${OPT_BACKUP} == 1 ]; then
    mv "${MAXMIND_PATH}/maxmind.mmdb" "${MAXMIND_PATH}/maxmind-$(date +%Y-%m-%d).mmdb"
  fi
  mv -f /tmp/maxmind/maxmind.mmdb "${MAXMIND_PATH}/maxmind.mmdb"
  rm -rf /tmp/maxmind
}

command_maxmind_fetch() {
  local KEY=${1:-$OPT_MAXMIND_KEY}
  local EDITION=${2:-$OPT_MAXMIND_EDITION}
  local DATABASE=${3:-$OPT_MAXMIND_DATABASE}
  if [ ! -z "${KEY}" ]; then
    download_maxmind $KEY $EDITION $DATABASE
  fi
}


###############################################################################
#                                 Main Section                                #
###############################################################################
if [ $# -eq 0 ]; then
  usage
  exit 1;
fi

COMMAND="${1:-}"
COMMAND="${COMMAND//-/_}"
if [ -z "$COMMAND" ]; then
  ERROR "No command was specified. Run with --help to see the usage. Maybe you want to run \`$ARG0 issue\`?"
fi

if ! command -v "command_${COMMAND}" > /dev/null 2>&1; then
  ERROR "Unknown command: ${COMMAND}. Run with --help to see the usage."
fi
shift

if ! args="$(getopt -o hs:e:d:o: --long help,server:,email:,domain:,output:,alt-domains:,debug -n "$ARG0" -- "$@")"; then
  usage
  exit 1
fi

set -- $args
while [ "$#" -gt 0 ]; do
  arg="$1"
  shift
  case "$arg" in
    -h | --help)
      usage
      exit 0
      ;;
    -s | --server)
      OPT_SERVER=$1
      shift
      ;;
    -e | --email)
      OPT_EMAIL=${1//\'/}
      shift
      ;;
    -d | --domain)
      if [ -z "${OPT_PRIMARY_DOMAIN}" ]; then
        OPT_PRIMARY_DOMAIN=${1//\'/}
      fi
      OPT_DOMAINS="${OPT_DOMAINS} ${1//\'/}"
      shift
      ;;
    -o | --output)
      OPT_OUTPUT=${1//\'/}
      shift
      ;;
    --debug)
      DEBUG_MODE=1
      ;;
    --)
      break
      ;;
    *)
      ERROR "Unknown argument '$arg' when parsing script arguments."
      exit 1
      ;;
  esac
done

echo "Command: ${COMMAND}"
echo "Primary Domain: ${OPT_PRIMARY_DOMAIN}"
echo "Domains: ${OPT_DOMAINS}"

if [ "${OPT_SSL_SERVER}" != "letsencrypt" ] && [ "${OPT_SSL_SERVER}" != "zerossl" ]; then
  ERROR "Invalid server ${OPT_SSL_SERVER} specified. Valid values are letsencrypt and zerossl"
fi

if [ ${COMMAND} == 'issue' ] || [ ${COMMAND} == 'renew' ]; then
  if [ -z "${OPT_OUTPUT}" ]; then
    ERROR "Output directory is required for issue and renew commands"
  fi
  if [ ! -d ${OPT_OUTPUT} ]; then
    mkdir -p ${OPT_OUTPUT}
  fi
fi

init
"command_${COMMAND}"
cleanup
